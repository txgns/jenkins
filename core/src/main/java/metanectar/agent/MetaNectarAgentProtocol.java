package metanectar.agent;

import hudson.model.Hudson;
import hudson.model.Hudson.MasterComputer;
import hudson.model.UsageStatistics.CombinedCipherInputStream;
import hudson.model.UsageStatistics.CombinedCipherOutputStream;
import hudson.remoting.Channel;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.net.URL;
import java.security.GeneralSecurityException;
import java.security.Signature;
import java.security.cert.X509Certificate;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.HashMap;
import java.util.Map;

/**
 * The Jenkins/Nectar protocol that establishes the channel with MetaNectar.
 *
 *
 * <h2>Security Architecture</h2>
 * <p>
 * This protocol involves two parties proving to each other who they are and establish
 * secure remoting channel, over an insecure transport. The protocol is symmetric.
 *
 * <p>
 * The "who they are" part hinges on an RSA key pair, much like how it's used in SSH.
 * The other side of the communication knows you are you via your public key.
 *
 * <p>
 * While we could have just gotten away with a bare public key, we use X509 certificate.
 * We are just using it to carry around a public key, and so it merely needs to be self-signed,
 * but use of the existing public key infrastructure can make the authorization easier down the road
 * (that is, an administrator needs to acknowledge that it approves of the given public key,
 * and doing so is easier if you use a certificate and especially if it has a trust chain.)
 *
 * <p>
 * The authentication is done by each side providing a signature on a random session ID.
 * For this to work, a random session ID needs to be generated by a coin-toss. So for that,
 * we do Diffie-Hellman key exchange.
 *
 * <p>
 * The protocol also exchanges the certificate, and each side will verify the signature,
 * check if it's willing to talk to the owner of the validated public key, then proceed.
 *
 * @author Paul Sandoz
 * @author Kohsuke Kawaguchi
 */
public class MetaNectarAgentProtocol implements AgentProtocol.Inbound, AgentProtocol.Outbound {
    /**
     * Certificate that shows the identity of this client.
     */
    private final X509Certificate identity;
    /**
     * Private key that pairs up with the {@link #identity}
     */
    private final RSAPrivateKey privateKey;

    private final Listener listener;

    /**
     * The HTTP URL of ours. {@link Hudson#getRootUrl()}.
     */
    private final URL address;

    public interface Listener {
        void onConnectingTo(URL address, X509Certificate serverIdentity) throws GeneralSecurityException;
        void onConnectedTo(Channel channel);
    }

    public MetaNectarAgentProtocol(X509Certificate identity, RSAPrivateKey privateKey, URL address, Listener listener) {
        this.identity = identity;
        this.privateKey = privateKey;
        this.listener = listener;
        this.address = address;
    }

    public String getName() {
        return "Protocol:MetaNectar";
    }

    public void process(Connection connection) throws Exception {
        byte[] sessionId = connection.diffieHellman().generateSecret();

        sendHandshake(connection, sessionId);
        X509Certificate other = receiveHandshake(connection, sessionId);
        connect(connection, other);
    }

    private void sendHandshake(Connection connection, byte[] sessionId) throws IOException, GeneralSecurityException {
        Signature sig = Signature.getInstance("SHA1withRSA");
        sig.initSign(privateKey);
        sig.update(sessionId);

        // use a map in preparation for possible future extension
        Map<String,Object> requestHeaders = new HashMap<String,Object>();
        requestHeaders.put("Identity", identity);
        requestHeaders.put("Address", address.toExternalForm());
        requestHeaders.put("Signature",sig.sign());

        connection.sendObject(requestHeaders);
    }

    private X509Certificate receiveHandshake(Connection connection, byte[] sessionId) throws IOException, GeneralSecurityException, ClassNotFoundException {
        Map<String, Object> responseHeaders = connection.readObject();

        X509Certificate server = (X509Certificate)responseHeaders.get("Identity");
        if (server==null)
            throw new IOException("The other end failed to give us its identity");
        URL serverAddress = new URL((String)responseHeaders.get("Address"));

        byte[] signature = (byte[])responseHeaders.get("Signature");
        Signature sig = Signature.getInstance("SHA1withRSA");
        sig.initVerify(server);
        sig.update(sessionId);
        if (!sig.verify(signature))
            throw new IOException("Signature mismatch. Someone is trying to masquerade?");

        listener.onConnectingTo(serverAddress, server);
        return server;
    }

    protected void connect(Connection connection, X509Certificate other) throws IOException, GeneralSecurityException {

        final Channel channel = new Channel("outbound-channel", MasterComputer.threadPoolForRemoting,
            new BufferedInputStream(new CombinedCipherInputStream(connection.in, (RSAPublicKey)other.getPublicKey(), "AES")),
            new BufferedOutputStream(new CombinedCipherOutputStream(connection.out, privateKey, "AES")));

        listener.onConnectedTo(channel);
    }
}
